{"title":"$:/plugins/linonetwo/watch-fs","description":"Reload changed tiddlers from disc","author":"LinOnetwo","core-version":">=5.1.22","plugin-type":"plugin","version":"0.0.1","list":"readme","dependents":"","type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\",\n            \"text\": \"/* eslint-disable global-require */\\n/* eslint-disable unicorn/filename-case */\\n/* \\\\\\n  title: $:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\\n  type: application/javascript\\n  module-type: startup\\n\\n  This file is modified based on $:/plugins/OokTech/Bob/FileSystemMonitor.js\\n\\\\ */\\n\\nconst isNotNonTiddlerFiles = filePath =>\\n  !filePath.includes('$__StoryList') &&\\n  !filePath.includes('/subwiki/') &&\\n  !filePath.endsWith('.DS_Store') &&\\n  !filePath.includes('.git');\\n\\nfunction FileSystemMonitor() {\\n  const isDebug = false;\\n  const debugLog = isDebug ? console.log : () => {};\\n\\n  exports.name = 'watch-fs_FileSystemMonitor';\\n  exports.after = ['load-modules', 'watch-fs_watch'];\\n  exports.platforms = ['node'];\\n  exports.synchronous = true;\\n\\n  // this allow us to test this module in nodejs directly without \\\"ReferenceError: $tw is not defined\\\"\\n  const $tw = this.$tw || { node: true };\\n  // init our namespace for communication\\n  $tw.wiki.watchFs = {};\\n  // folder to watch\\n  // non-tiddler files that needs to be ignored\\n\\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\\n  const deepEqual = require('./deep-equal');\\n  const fs = require('fs');\\n  const path = require('path');\\n\\n  const watchPathBase = path.resolve(\\n    $tw.boot.wikiInfo?.config?.watchFolder || $tw.boot.wikiTiddlersPath || './tiddlers',\\n  );\\n  debugLog(`watchPathBase`, JSON.stringify(watchPathBase, undefined, '  '));\\n\\n  /**\\n   * $tw.boot.files: {\\n   *   [tiddlerTitle: string]: {\\n   *     filepath: '/Users/linonetwo/xxxx/wiki/Meme-of-LinOnetwo/tiddlers/tiddlerTitle.tid',\\n   *     type: 'application/x-tiddler',\\n   *     hasMetaFile: false\\n   *   }\\n   * }\\n   */\\n  const initialLoadedFiles = $tw.boot.files;\\n\\n  /**\\n   * we can use this for getTitleByPath\\n   * {\\n   *   [filepath: string]: {\\n   *     filepath: '/Users/linonetwo/xxxx/wiki/Meme-of-LinOnetwo/tiddlers/tiddlerTitle.tid',\\n   *     tiddlerTitle: string,\\n   *     type: 'application/x-tiddler',\\n   *     hasMetaFile: false\\n   *   }\\n   * }\\n   */\\n  const inverseFilesIndex = {};\\n  $tw.wiki.watchFs.inverseFilesIndex = inverseFilesIndex;\\n  // initialize the inverse index\\n  for (const tiddlerTitle in initialLoadedFiles) {\\n    if ({}.hasOwnProperty.call(initialLoadedFiles, tiddlerTitle)) {\\n      const fileDescriptor = initialLoadedFiles[tiddlerTitle];\\n      const fileRelativePath = path.relative(watchPathBase, fileDescriptor.filepath);\\n      inverseFilesIndex[fileRelativePath] = { ...fileDescriptor, filepath: fileRelativePath, tiddlerTitle };\\n    }\\n  }\\n\\n  // Helpers to maintain our cached index for file path and tiddler title\\n  const updateInverseIndex = (filePath, fileDescriptor) => {\\n    if (fileDescriptor) {\\n      inverseFilesIndex[filePath] = fileDescriptor;\\n    } else {\\n      delete inverseFilesIndex[filePath];\\n    }\\n  };\\n  const filePathExistsInIndex = filePath => !!inverseFilesIndex[filePath];\\n  const getTitleByPath = filePath => {\\n    try {\\n      return inverseFilesIndex[filePath].tiddlerTitle;\\n    } catch {\\n      // fatal error, shutting down.\\n      watcher.close();\\n      throw new Error(`${filePath}\\\\n↑ not existed in watch-fs plugin's FileSystemMonitor's inverseFilesIndex`);\\n    }\\n  };\\n  /**\\n   * This is a rarely used function maybe only when user rename a tiddler on the disk,\\n   * we need to get old tiddler path by its name\\n   * @param {string} title\\n   */\\n  const getPathByTitle = title => {\\n    try {\\n      for (const filePath in inverseFilesIndex) {\\n        if (inverseFilesIndex[filePath].title === title || inverseFilesIndex[filePath].title === `${title}.tid`) {\\n          return filePath;\\n        }\\n      }\\n      throw new Error('getPathByTitle');\\n    } catch {\\n      // fatal error, shutting down.\\n      watcher.close();\\n      throw new Error(`${title}\\\\n↑ not existed in watch-fs plugin's FileSystemMonitor's inverseFilesIndex`);\\n    }\\n  };\\n\\n  /**\\n   * A mutex to ignore temporary file created or deleted by this plugin.\\n   *\\n   * Set<filePath: string>\\n   */\\n  const lockedFiles = new Set();\\n\\n  // every time a file changed, refresh the count down timer, so only when disk get stable after a while, will we sync to the browser\\n  $tw.wiki.watchFs.canSync = false;\\n  const debounceInterval = 4 * 1000;\\n  let syncTimeoutHandler = undefined;\\n  const refreshCanSyncState = () => {\\n    $tw.wiki.watchFs.canSync = false;\\n    debugLog(`canSync is now ${$tw.wiki.watchFs.canSync}`);\\n    clearTimeout(syncTimeoutHandler);\\n    syncTimeoutHandler = setTimeout(() => {\\n      $tw.wiki.watchFs.canSync = true;\\n      debugLog(`canSync is now ${$tw.wiki.watchFs.canSync}`);\\n    }, debounceInterval);\\n  };\\n\\n  /**\\n   * This watches for changes to a folder and updates the wiki when anything changes in the folder.\\n   *\\n   * The filePath reported by listener is not the actual tiddler name, and all tiddlywiki operations requires that we have the name of tiddler,\\n   * So we have get tiddler name by path from `$tw.boot.files`.\\n   *\\n   * Then we can perform following logic:\\n   * File update -> update or create tiddler using `$tw.syncadaptor.wiki.addTiddler`\\n   * File remove & tiddler exist in wiki -> then remove tiddler using `$tw.syncadaptor.wiki.deleteTiddler`\\n   * File remove & tiddler not exist in wiki -> This change is caused by tiddlywiki itself, do noting here\\n   *\\n   * @param {\\\"update\\\" | \\\"remove\\\"} changeType\\n   * @param {*} filePath changed file's relative path to the folder executing this watcher\\n   */\\n  const listener = (changeType, filePath) => {\\n    const fileRelativePath = path.relative(watchPathBase, filePath);\\n    const fileAbsolutePath = path.join(watchPathBase, fileRelativePath);\\n    debugLog(`${fileRelativePath} ${changeType}`);\\n    if (lockedFiles.has(fileRelativePath)) {\\n      debugLog(`${fileRelativePath} ignored due to mutex lock`);\\n      // release lock as we have already finished our job\\n      lockedFiles.delete(fileRelativePath);\\n      return;\\n    }\\n    // on create or modify\\n    if (changeType === 'update') {\\n      // get tiddler from the disk\\n      /**\\n       * tiddlersDescriptor:\\n       * {\\n       *    \\\"filepath\\\": \\\"Meme-of-LinOnetwo/tiddlers/$__StoryList.tid\\\",\\n       *    \\\"type\\\": \\\"application/x-tiddler\\\",\\n       *    \\\"tiddlers\\\": [\\n       *      {\\n       *        \\\"title\\\": \\\"$:/StoryList\\\",\\n       *        \\\"list\\\": \\\"Index\\\"\\n       *      }\\n       *    ],\\n       *    \\\"hasMetaFile\\\": false\\n       *  }\\n       */\\n      const tiddlersDescriptor = $tw.loadTiddlersFromFile(fileAbsolutePath, { title: fileAbsolutePath });\\n      debugLog(`tiddlersDescriptor`, JSON.stringify(tiddlersDescriptor, undefined, '  '));\\n      const { tiddlers, ...fileDescriptor } = tiddlersDescriptor;\\n      // if user is using git or VSCode to create new file in the disk, that is not yet exist in the wiki\\n      // but maybe our index is not updated, or maybe user is modify a system tiddler, we need to check each case\\n      if (!filePathExistsInIndex(fileRelativePath)) {\\n        tiddlers.forEach(tiddler => {\\n          // check whether we are rename an existed tiddler\\n          debugLog('getting new tiddler.title', tiddler.title);\\n          const existedWikiRecord = $tw.wiki.getTiddler(tiddler.title);\\n          if (existedWikiRecord && deepEqual(tiddler, existedWikiRecord.fields)) {\\n            // because disk file and wiki tiddler is identical, so this file creation is triggered by wiki.\\n            // We just update the index.\\n            // But it might also be user changing the name of the file, so filename to be different with the actual tiddler title, while tiddler content is still same as old one\\n            // We allow filename to be different with the tiddler title, but we need to handle this in the inverse index to prevent the error that we can't get tiddler from index by its path\\n            debugLog('fileDescriptor.tiddlerTitle', fileDescriptor.tiddlerTitle);\\n            if (\\n              fileDescriptor.tiddlerTitle &&\\n              fileDescriptor.tiddlerTitle !== `${tiddler.title}.tid` &&\\n              fileDescriptor.tiddlerTitle !== tiddler.title\\n            ) {\\n              // We have no API in tw to inform $tw about we have a file changed its name, but remain its tiddler title\\n              // because to do that now we have to use `$tw.syncadaptor.wiki.addTiddler(tiddler);`, which will create a new file with the title we pass to it, it can't assign a disk file name while create a new tiddler\\n              throw new Error('Rename filename is not supported, please submit your idea to improve this logic');\\n              // updateInverseIndex(fileRelativePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\\n            } else {\\n              updateInverseIndex(fileRelativePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\\n            }\\n          } else {\\n            updateInverseIndex(fileRelativePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\\n            $tw.syncadaptor.wiki.addTiddler(tiddler);\\n          }\\n        });\\n      } else {\\n        // if it already existed in the wiki, this change might 1. due to our last call to `$tw.syncadaptor.wiki.addTiddler`; 2. due to user change in git or VSCode\\n        // so we have to check whether tiddler in the disk is identical to the one in the wiki, if so, we ignore it in the case 1.\\n        tiddlers\\n          .filter(tiddler => {\\n            debugLog('updating existed tiddler', tiddler.title);\\n            const { fields: tiddlerInWiki } = $tw.wiki.getTiddler(tiddler.title);\\n            if (deepEqual(tiddler, tiddlerInWiki)) {\\n              debugLog('Ignore update due to change from the Browser', tiddler.title);\\n              return false;\\n            }\\n            debugLog('Saving updated', tiddler.title);\\n            return true;\\n          })\\n          // then we update wiki with each newly created tiddler\\n          .forEach(tiddler => {\\n            $tw.syncadaptor.wiki.addTiddler(tiddler);\\n          });\\n      }\\n    }\\n\\n    // on delete\\n    if (changeType === 'remove') {\\n      debugLog('handle remove', fileRelativePath);\\n      const tiddlerTitle = getTitleByPath(fileRelativePath);\\n\\n      // if this tiddler is not existed in the wiki, this means this deletion is triggered by wiki\\n      // we only react on event that triggered by the git or VSCode\\n      const existedTiddlerResult = $tw.wiki.getTiddler(tiddlerTitle);\\n      debugLog('existedTiddlerResult', existedTiddlerResult);\\n      if (!existedTiddlerResult) {\\n        debugLog('file already deleted by wiki', fileAbsolutePath);\\n        updateInverseIndex(fileRelativePath);\\n      } else {\\n        // now event is triggered by the git or VSCode\\n        // ask tiddlywiki to delete the file, we first need to create a fake file for it to delete\\n        // can't directly use $tw.wiki.syncadaptor.deleteTiddler(tiddlerTitle);  because it will try to modify fs, and will failed:\\n        /* Sync error while processing delete of 'blabla': Error: ENOENT: no such file or directory, unlink '/Users//Desktop/repo/wiki/Meme-of-LinOnetwo/tiddlers/blabla.tid'\\n          syncer-server-filesystem: Dispatching 'delete' task: blabla \\n          Sync error while processing delete of 'blabla': Error: ENOENT: no such file or directory, unlink '/Users//Desktop/repo/wiki/Meme-of-LinOnetwo/tiddlers/blabla.tid' */\\n        lockedFiles.add(fileRelativePath);\\n        debugLog('trying to delete', fileAbsolutePath);\\n        fs.writeFile(fileAbsolutePath, '', {}, () => {\\n          $tw.syncadaptor.wiki.deleteTiddler(tiddlerTitle);\\n          // sometime deleting system tiddler will result in an empty file, we need to try delete that empty file\\n          try {\\n            if (\\n              fileAbsolutePath.startsWith('$') &&\\n              fs.existsSync(fileAbsolutePath) &&\\n              fs.readFileSync(fileAbsolutePath, 'utf-8').length === 0\\n            ) {\\n              fs.unlinkSync(fileAbsolutePath);\\n            }\\n          } catch (error) {\\n            console.error(error);\\n          }\\n          updateInverseIndex(fileRelativePath);\\n        });\\n      }\\n    }\\n\\n    refreshCanSyncState();\\n  };\\n\\n  // use node-watch\\n  const watch = require('./watch');\\n  const watcher = watch(watchPathBase, { recursive: true, delay: 200, filter: isNotNonTiddlerFiles }, listener);\\n}\\nFileSystemMonitor();\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/config/SyncPollingInterval\": {\n            \"title\": \"$:/config/SyncPollingInterval\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"32140800000\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/deep-equal.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/deep-equal.js\",\n            \"text\": \"module.exports = function deepEqual(x, y) {\\n  if (x === y) {\\n    return true;\\n  }\\n  if (titleListEqual(x, y)) {\\n    // handle title list https://tiddlywiki.com/#Title%20List\\n    /* tiddler {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"list\\\": \\\"Index\\\"\\n    }\\n    tiddlerInWiki {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"list\\\": [\\n        \\\"Index\\\"\\n      ]\\n    } */\\n    return true;\\n  }\\n  if (timeStampEqual(x, y)) {\\n    // handles time stamp format\\n    /* tiddler {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"created\\\": \\\"20200806161101351\\\",\\n      \\\"list\\\": \\\"Index\\\",\\n      \\\"modified\\\": \\\"20200806161101351\\\",\\n      \\\"type\\\": \\\"text/vnd.tiddlywiki\\\"\\n    }\\n    tiddlerInWiki {\\n      \\\"title\\\": \\\"$:/StoryList\\\",\\n      \\\"created\\\": \\\"2020-08-06T16:11:01.351Z\\\",\\n      \\\"list\\\": [\\n        \\\"Index\\\"\\n      ],\\n      \\\"modified\\\": \\\"2020-08-06T16:11:01.351Z\\\",\\n      \\\"type\\\": \\\"text/vnd.tiddlywiki\\\"\\n    } */\\n    return true;\\n  }\\n  if (typeof x === 'object' && x !== null && typeof y === 'object' && y !== null) {\\n    if (Object.keys(x).length !== Object.keys(y).length) return false;\\n\\n    for (const property in x) {\\n      if (!deepEqual(x[property], y[property])) return false;\\n    }\\n\\n    return true;\\n  }\\n  return false;\\n};\\n\\nfunction titleListEqual(x, y) {\\n  // y is like \\\"GettingStarted [[Discover TiddlyWiki]] Upgrading\\\", and x is an array\\n  if (typeof x === 'string' && Array.isArray(y)) {\\n    // $tw.utils.parseStringArray is heavy, so we use $tw.utils.stringifyList instead\\n    return $tw.utils.stringifyList(y) === x;\\n  }\\n  if (typeof y === 'string' && Array.isArray(x)) {\\n    return $tw.utils.stringifyList(x) === y;\\n  }\\n  return false;\\n}\\n\\nfunction timeStampEqual(x, y) {\\n  // strangely, `created` and `modified` field is not instanceof Date, so have to use x === 'object' to check it\\n  if (typeof y === 'object' && y.toString && Object.keys(y).length === 0 && typeof x === 'string') {\\n    return JSON.stringify(y).replace(/[\\\".:TZ-]/g, '') === x;\\n  }\\n  if (typeof x === 'object' && x.toString && Object.keys(x).length === 0 && typeof y === 'string') {\\n    return JSON.stringify(x).replace(/[\\\".:TZ-]/g, '') === y;\\n  }\\n  if (typeof x === 'string' && typeof y === 'string') {\\n    return x.replace(/[.:TZ-]/g, '') === y || y.replace(/[.:TZ-]/g, '') === x;\\n  }\\n  return false;\\n}\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/get-can-sync.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/get-can-sync.js\",\n            \"text\": \"/*\\\\\\ntitle: $:/plugins/linonetwo/watch-fs/get-can-sync.js\\ntype: application/javascript\\nmodule-type: route\\nGET /watch-fs-can-sync\\n\\\\*/\\n(function () {\\n  exports.method = 'GET';\\n\\n  // route should start with something https://github.com/Jermolene/TiddlyWiki5/issues/4807\\n  exports.path = /^\\\\/linonetwo\\\\/watch-fs-can-sync$/;\\n\\n  exports.handler = function handler(request, response, state) {\\n    response.writeHead(200, { 'Content-Type': 'application/json' });\\n    const { canSync } = state.wiki.watchFs;\\n    response.end(JSON.stringify(canSync), 'utf8');\\n  };\\n})();\\n\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"route\",\n            \"creator\": \"LinOnetwo\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/has-native-recursive.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/has-native-recursive.js\",\n            \"text\": \"/**\\n  title: $:/plugins/linonetwo/watch-fs/has-native-recursive.js\\n  type: application/javascript\\n  module-type: startup\\n * https://github.com/yuanchuan/node-watch\\n * @version 0.6.4\\n */\\nfunction hasNativeRecursiveIIFE() {\\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\\n  exports.name = 'watch-fs_has-native-recursive';\\n  exports.after = ['load-modules', 'watch-fs_is'];\\n  exports.platforms = ['node'];\\n  exports.synchronous = true;\\n\\n  const fs = require('fs');\\n  const os = require('os');\\n  const path = require('path');\\n  const is = require('./is');\\n\\n  let IS_SUPPORT;\\n  const TEMP_DIR = (os.tmpdir && os.tmpdir()) || process.env.TMPDIR || process.env.TEMP || process.cwd();\\n\\n  function TemporaryStack() {\\n    this.stack = [];\\n  }\\n\\n  TemporaryStack.prototype = {\\n    create(type, base) {\\n      const name = path.join(\\n        base,\\n        `node-watch-${Math.random()\\n          .toString(16)\\n          .slice(2)}`,\\n      );\\n      this.stack.push({ name, type });\\n      return name;\\n    },\\n    write(/* file */) {\\n      for (const argument of arguments) {\\n        fs.writeFileSync(argument, ' ');\\n      }\\n    },\\n    mkdir(/* dirs */) {\\n      for (const argument of arguments) {\\n        fs.mkdirSync(argument);\\n      }\\n    },\\n    cleanup(fn) {\\n      try {\\n        let temporary;\\n        while ((temporary = this.stack.pop())) {\\n          const { type } = temporary;\\n          const { name } = temporary;\\n          if (type === 'file' && is.file(name)) {\\n            fs.unlinkSync(name);\\n          } else if (type === 'dir' && is.directory(name)) {\\n            fs.rmdirSync(name);\\n          }\\n        }\\n      } finally {\\n        if (is.func(fn)) fn();\\n      }\\n    },\\n  };\\n\\n  let pending = false;\\n\\n  module.exports = function hasNativeRecursive(fn) {\\n    if (!is.func(fn)) {\\n      return false;\\n    }\\n    if (IS_SUPPORT !== undefined) {\\n      return fn(IS_SUPPORT);\\n    }\\n\\n    if (!pending) {\\n      pending = true;\\n    }\\n    // check again later\\n    else {\\n      return setTimeout(function() {\\n        hasNativeRecursive(fn);\\n      }, 300);\\n    }\\n\\n    const stack = new TemporaryStack();\\n    const parent = stack.create('dir', TEMP_DIR);\\n    const child = stack.create('dir', parent);\\n    const file = stack.create('file', child);\\n\\n    stack.mkdir(parent, child);\\n\\n    const options = { recursive: true };\\n    let watcher;\\n\\n    try {\\n      watcher = fs.watch(parent, options);\\n    } catch (error) {\\n      if (error.code == 'ERR_FEATURE_UNAVAILABLE_ON_PLATFORM') {\\n        return fn((IS_SUPPORT = false));\\n      }\\n      throw error;\\n    }\\n\\n    if (!watcher) {\\n      return false;\\n    }\\n\\n    const timer = setTimeout(function() {\\n      watcher.close();\\n      stack.cleanup(function() {\\n        fn((IS_SUPPORT = false));\\n      });\\n    }, 200);\\n\\n    watcher.on('change', function(event, name) {\\n      if (path.basename(file) === path.basename(name)) {\\n        watcher.close();\\n        clearTimeout(timer);\\n        stack.cleanup(function() {\\n          fn((IS_SUPPORT = true));\\n        });\\n      }\\n    });\\n    stack.write(file);\\n  };\\n}\\nhasNativeRecursiveIIFE();\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/is.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/is.js\",\n            \"text\": \"/**\\n  title: $:/plugins/linonetwo/watch-fs/is.js\\n  type: application/javascript\\n  module-type: startup\\n * https://github.com/yuanchuan/node-watch\\n * @version 0.6.4\\n */\\n\\nfunction isIIFE() {\\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\\n  exports.name = 'watch-fs_is';\\n  exports.after = ['load-modules'];\\n  exports.platforms = ['node'];\\n  exports.synchronous = true;\\n\\n  const fs = require('fs');\\n  const path = require('path');\\n  const os = require('os');\\n\\n  function matchObject(item, string) {\\n    return Object.prototype.toString.call(item) === `[object ${string}]`;\\n  }\\n\\n  function checkStat(name, fn) {\\n    try {\\n      return fn(name);\\n    } catch (error) {\\n      if (/^(ENOENT|EPERM|EACCES)$/.test(error.code)) {\\n        if (error.code !== 'ENOENT') {\\n          console.warn('Warning: Cannot access %s', name);\\n        }\\n        return false;\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  const is = {\\n    nil(item) {\\n      return item == undefined;\\n    },\\n    array(item) {\\n      return Array.isArray(item);\\n    },\\n    emptyObject(item) {\\n      for (const key in item) {\\n        return false;\\n      }\\n      return true;\\n    },\\n    buffer(item) {\\n      return Buffer.isBuffer(item);\\n    },\\n    regExp(item) {\\n      return matchObject(item, 'RegExp');\\n    },\\n    string(item) {\\n      return matchObject(item, 'String');\\n    },\\n    func(item) {\\n      return typeof item === 'function';\\n    },\\n    number(item) {\\n      return matchObject(item, 'Number');\\n    },\\n    exists(name) {\\n      return fs.existsSync(name);\\n    },\\n    file(name) {\\n      return checkStat(name, function(n) {\\n        return fs.statSync(n).isFile();\\n      });\\n    },\\n    samePath(a, b) {\\n      return path.resolve(a) === path.resolve(b);\\n    },\\n    directory(name) {\\n      return checkStat(name, function(n) {\\n        return fs.statSync(n).isDirectory();\\n      });\\n    },\\n    symbolicLink(name) {\\n      return checkStat(name, function(n) {\\n        return fs.lstatSync(n).isSymbolicLink();\\n      });\\n    },\\n    windows() {\\n      return os.platform() === 'win32';\\n    },\\n  };\\n\\n  module.exports = is;\\n}\\nisIIFE();\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/readme\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/readme\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"text/vnd.tiddlywiki\",\n            \"text\": \"!! About\\n\\nThis plugin enables TiddlyWiki to watch the change in your disk, and if you edit one of your tiddler using editor likes VSCode and save it on the disk, the change will immediately reflected in the browser.\\n\\nSee [[https://github.com/Jermolene/TiddlyWiki5/issues/3060]] for related discussions.\\n\\n!! [[FileSystemMonitor.js|$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js]]\\n\\nThis module watches the file system in the tiddlers folder and any changes to\\nthe files in the folder that don't come from the browser are reported to the\\nbrowser. So if you make a new .tid file in the tiddlers folder it will appear\\nin the wiki in the browser without needing to restart the server. You can also\\ndelete files to remove the tiddlers from the browser.\\n\\n!! Usage\\n\\nThis plugin will cause trouble if you build wiki with it enabled,\\nso you have to remove it from your `tiddlywiki.info`, and add it to your wiki start arguments:\\n\\n```shell\\ntiddlywiki +plugins/tiddlywiki/filesystem +plugins/tiddlywiki/tiddlyweb +plugins/linonetwo/watch-fs <path-to-wiki-folder> --listen\\n```\\n\\n(why `+plugins/tiddlywiki/filesystem +plugins/tiddlywiki/tiddlyweb` here? See [[https://github.com/Jermolene/TiddlyWiki5/issues/4484#issuecomment-613200370]] for details)\\n\\n!!! Liminitation\\n\\n# can't handle rename in the disk, you can only rename from within the wiki (no such API to tell tw I've renamed a file)\\n# I haven't tested this with [[$:/config/FileSystemPaths]] and [[Fix file info PR|https://github.com/Jermolene/TiddlyWiki5/pull/4630]] , but I use this feature every day, so I will definitely support it.\\n# Can't handle if git change the tiddler while you are open its Draft tiddler (might be fixed by [[Deleting a draft tiddler should not also delete the original tiddler|https://github.com/Jermolene/TiddlyWiki5/issues/4792]] )\\n\\n!! Implementation Details\\n\\n!!! How to decide whether a change is comes from the browser?\\n\\nWe will compare disk file and wiki file, if there is any discrepancy,\\nthen we know the change is not made from the wiki, it is made by git or VSCode, in this case we read data from the disc,\\nand add data to the tiddlywiki.\\n\\n!!! How to sync changes to the browser?\\n\\nwe can't trigger sync from the server, so we have to set a smaller sync interval in the client side.\\n\\nSo this plugin ship with a large [[$:/config/SyncPollingInterval]] to disable the build-in sync,\\nand we add a new route `/linonetwo/watch-fs-can-sync` to the simple server, it will return `true` or `false`,\\nand browser will poll this route, to see if it needs to trigger a `$tw.syncer.syncFromServer()`.\\n\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/trigger-sync.html\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/trigger-sync.html\",\n            \"text\": \"<script type=\\\"application/javascript\\\">\\n  const checkCanSyncInterval = 1000; // ms\\n  // after we sync, set this to false\\n  let deSync = false;\\n  setInterval(async function checkCanSync() {\\n    // debounced sync indicator, will be true if there is no change in the disc for several seconds\\n    const canSync = (await fetch('/linonetwo/watch-fs-can-sync').then((response) => response.text())) === 'true';\\n    if (!deSync && !canSync) {\\n      // we have previously synced, and server have changes that is not debounced yet\\n      deSync = true;\\n    }\\n    if (canSync && deSync) {\\n      $tw.syncer.syncFromServer();\\n      deSync = false;\\n    }\\n  }, checkCanSyncInterval);\\n</script>\\n\",\n            \"type\": \"text/html\",\n            \"creator\": \"LinOnetwo\",\n            \"tags\": \"$:/tags/RawMarkup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/utils.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/utils.js\",\n            \"text\": \"/**\\n * Given a tiddler title and an array of existing filenames, generate a new legal filename for the title,\\n * case insensitively avoiding the array of existing filenames\\n *\\n * Modified from TW-Bob's FileSystem/MultiWikiAdaptor.js\\n *\\n * @param {string} title\\n */\\nfunction generateTiddlerBaseFilepath(title) {\\n  let baseFilename;\\n  // Check whether the user has configured a tiddler -> pathname mapping\\n  const pathNameFilters = $tw.wiki.getTiddlerText('$:/config/FileSystemPaths');\\n  if (pathNameFilters) {\\n    const source = $tw.wiki.makeTiddlerIterator([title]);\\n    baseFilename = this.findFirstFilter(pathNameFilters.split('\\\\n'), source);\\n    if (baseFilename) {\\n      // Interpret \\\"/\\\" and \\\"\\\\\\\" as path separator\\n      baseFilename = baseFilename.replace(/\\\\/|\\\\\\\\/g, path.sep);\\n    }\\n  }\\n  if (!baseFilename) {\\n    // No mappings provided, or failed to match this tiddler so we use title as filename\\n    baseFilename = title.replace(/\\\\/|\\\\\\\\/g, '_');\\n  }\\n  // Remove any of the characters that are illegal in Windows filenames\\n  baseFilename = $tw.utils.transliterate(baseFilename.replace(/<|>|\\\\:|\\\\\\\"|\\\\||\\\\?|\\\\*|\\\\^/g, '_'));\\n  // Truncate the filename if it is too long\\n  if (baseFilename.length > 200) {\\n    baseFilename = baseFilename.substr(0, 200);\\n  }\\n  return baseFilename;\\n}\\n\\nfunction findFirstFilter(filters, source) {\\n  for (let i = 0; i < filters.length; i++) {\\n    const result = $tw.wiki.filterTiddlers(filters[i], null, source);\\n    if (result.length > 0) {\\n      return result[0];\\n    }\\n  }\\n  return null;\\n}\\n\\nmodule.exports = {\\n  generateTiddlerBaseFilepath,\\n};\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        },\n        \"$:/plugins/linonetwo/watch-fs/watch.js\": {\n            \"title\": \"$:/plugins/linonetwo/watch-fs/watch.js\",\n            \"text\": \"/**\\n  title: $:/plugins/linonetwo/watch-fs/watch.js\\n  type: application/javascript\\n  module-type: startup\\n * https://github.com/yuanchuan/node-watch\\n * @version 0.6.4\\n */\\n\\nfunction watchIIFE() {\\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\\n  exports.name = 'watch-fs_watch';\\n  exports.after = ['load-modules', 'watch-fs_is', 'watch-fs_has-native-recursive'];\\n  exports.platforms = ['node'];\\n  exports.synchronous = true;\\n\\n  const fs = require('fs');\\n  const path = require('path');\\n  const util = require('util');\\n  const events = require('events');\\n\\n  const hasNativeRecursive = require('./has-native-recursive');\\n  const is = require('./is');\\n\\n  const EVENT_UPDATE = 'update';\\n  const EVENT_REMOVE = 'remove';\\n\\n  function hasDup(array) {\\n    return array.some(function(v, i, self) {\\n      return self.indexOf(v) !== i;\\n    });\\n  }\\n\\n  function unique(array) {\\n    return array.filter(function(v, i, self) {\\n      return self.indexOf(v) === i;\\n    });\\n  }\\n\\n  function assertEncoding(encoding) {\\n    if (encoding && encoding !== 'buffer' && !Buffer.isEncoding(encoding)) {\\n      throw new Error(`Unknown encoding: ${encoding}`);\\n    }\\n  }\\n\\n  function guard(fn) {\\n    return function(argument, action) {\\n      if (is.func(fn)) {\\n        if (fn(argument)) action();\\n      } else if (is.regExp(fn)) {\\n        if (fn.test(argument)) action();\\n      } else {\\n        action();\\n      }\\n    };\\n  }\\n\\n  function composeMessage(names) {\\n    return names.map(function(n) {\\n      return is.exists(n) ? [EVENT_UPDATE, n] : [EVENT_REMOVE, n];\\n    });\\n  }\\n\\n  function getMessages(cache) {\\n    let filtered = unique(cache);\\n\\n    // Saving file from an editor? If so, assuming the\\n    // non-existed files in the cache are temporary files\\n    // generated by an editor and thus be filtered.\\n    const reg = /~$|^\\\\.#|^##$/g;\\n    const hasSpecialChar = cache.some(function(c) {\\n      return reg.test(c);\\n    });\\n\\n    if (hasSpecialChar) {\\n      const dup = hasDup(\\n        cache.map(function(c) {\\n          return c.replace(reg, '');\\n        }),\\n      );\\n      if (dup) {\\n        filtered = filtered.filter(function(m) {\\n          return is.exists(m);\\n        });\\n      }\\n    }\\n\\n    // Prevent redundant event for its parent when creating file/directory.\\n    // The operation is kinda expensive so only be triggered under Windows.\\n    // https://github.com/yuanchuan/node-watch/issues/79\\n    if (is.windows()) {\\n      const parents = filtered.map(function(n) {\\n        return path.parse(n).dir;\\n      });\\n      filtered = filtered.filter(function(n) {\\n        // Skip on removal\\n        if (!is.exists(n)) {\\n          return true;\\n        }\\n        // Ignore the parent directory\\n        return !parents.some(function(m) {\\n          return is.samePath(n, m);\\n        });\\n      });\\n    }\\n\\n    return composeMessage(filtered);\\n  }\\n\\n  function debounce(info, fn) {\\n    let timer;\\n    let cache = [];\\n    const { encoding } = info.options;\\n    let { delay } = info.options;\\n    if (!is.number(delay)) {\\n      delay = 200;\\n    }\\n    function handle() {\\n      getMessages(cache).forEach(function(message) {\\n        message[1] = Buffer.from(message[1]);\\n        if (encoding !== 'buffer') {\\n          message[1] = message[1].toString(encoding);\\n        }\\n        fn.apply(null, message);\\n      });\\n      timer = null;\\n      cache = [];\\n    }\\n    return function(rawEvent, name) {\\n      cache.push(name);\\n      if (!timer) {\\n        timer = setTimeout(handle, delay);\\n      }\\n    };\\n  }\\n\\n  function createDupsFilter() {\\n    let memo = {};\\n    return function(fn) {\\n      return function(event, name) {\\n        memo[event + name] = [event, name];\\n        setTimeout(function() {\\n          Object.keys(memo).forEach(function(n) {\\n            fn.apply(null, memo[n]);\\n          });\\n          memo = {};\\n        });\\n      };\\n    };\\n  }\\n\\n  function getSubDirectories(dir, fn, done = function() {}) {\\n    if (is.directory(dir)) {\\n      fs.readdir(dir, function(error, all) {\\n        if (error) {\\n          // don't throw permission errors.\\n          if (/^(EPERM|EACCES)$/.test(error.code)) {\\n            console.warn('Warning: Cannot access %s.', dir);\\n          } else {\\n            throw error;\\n          }\\n        } else {\\n          all.forEach(function(f) {\\n            const sdir = path.join(dir, f);\\n            if (is.directory(sdir)) fn(sdir);\\n          });\\n          done();\\n        }\\n      });\\n    } else {\\n      done();\\n    }\\n  }\\n\\n  function semaphore(final) {\\n    let counter = 0;\\n    return function start() {\\n      counter++;\\n      return function stop() {\\n        counter--;\\n        if (counter === 0) final();\\n      };\\n    };\\n  }\\n\\n  function nullCounter() {\\n    return function nullStop() {};\\n  }\\n\\n  const deprecationWarning = util.deprecate(function() {},\\n  '(node-watch) First param in callback function\\\\\\n  is replaced with event name since 0.5.0, use\\\\\\n  `(evt, filename) => {}` if you want to get the filename');\\n\\n  function Watcher() {\\n    events.EventEmitter.call(this);\\n    this.watchers = {};\\n    this._isReady = false;\\n    this._isClosed = false;\\n  }\\n\\n  util.inherits(Watcher, events.EventEmitter);\\n\\n  Watcher.prototype.expose = function() {\\n    const self = this;\\n    const methods = ['on', 'emit', 'close', 'isClosed', 'listeners', 'once', 'setMaxListeners', 'getMaxListeners'];\\n    return methods.reduce(function(expose, name) {\\n      expose[name] = function() {\\n        return self[name].apply(self, arguments);\\n      };\\n      return expose;\\n    }, {});\\n  };\\n\\n  Watcher.prototype.isClosed = function() {\\n    return this._isClosed;\\n  };\\n\\n  Watcher.prototype.close = function(fullPath) {\\n    const self = this;\\n    if (fullPath) {\\n      const watcher = this.watchers[fullPath];\\n      if (watcher && watcher.close) {\\n        watcher.close();\\n        delete self.watchers[fullPath];\\n      }\\n      getSubDirectories(fullPath, function(fpath) {\\n        self.close(fpath);\\n      });\\n    } else {\\n      Object.keys(self.watchers).forEach(function(fpath) {\\n        const watcher = self.watchers[fpath];\\n        if (watcher && watcher.close) {\\n          watcher.close();\\n        }\\n      });\\n      this.watchers = {};\\n    }\\n    // Do not close the Watcher unless all child watchers are closed.\\n    // https://github.com/yuanchuan/node-watch/issues/75\\n    if (is.emptyObject(self.watchers)) {\\n      this._isClosed = true;\\n      process.nextTick(emitClose, this);\\n    }\\n  };\\n\\n  function emitReady(self) {\\n    if (!self._isReady) {\\n      self._isReady = true;\\n      // do not call emit for 'ready' until after watch() has returned,\\n      // so that consumer can call on().\\n      process.nextTick(function() {\\n        self.emit('ready');\\n      });\\n    }\\n  }\\n\\n  function emitClose(self) {\\n    self.emit('close');\\n  }\\n\\n  Watcher.prototype.add = function(watcher, info) {\\n    const self = this;\\n    info = info || { fpath: '' };\\n    const watcherPath = path.resolve(info.fpath);\\n    this.watchers[watcherPath] = watcher;\\n\\n    // Internal callback for handling fs.FSWatcher 'change' events\\n    const internalOnChange = function(rawEvent, rawName) {\\n      if (self.isClosed()) {\\n        return;\\n      }\\n\\n      // normalise lack of name and convert to full path\\n      let name = rawName;\\n      if (is.nil(name)) {\\n        name = '';\\n      }\\n      name = path.join(info.fpath, name);\\n\\n      if (info.options.recursive) {\\n        hasNativeRecursive(function(has) {\\n          if (!has) {\\n            const fullPath = path.resolve(name);\\n            // remove watcher on removal\\n            if (!is.exists(name)) {\\n              self.close(fullPath);\\n            }\\n            // watch new created directory\\n            else if (is.directory(name) && !self.watchers[fullPath]) {\\n              self.watchDirectory(name, info.options);\\n            }\\n          }\\n        });\\n      }\\n\\n      handlePublicEvents(rawEvent, name);\\n    };\\n\\n    // Debounced based on the 'delay' option\\n    var handlePublicEvents = debounce(info, function(event, name) {\\n      // watch single file\\n      if (info.compareName) {\\n        if (info.compareName(name)) {\\n          self.emit('change', event, name);\\n        }\\n      }\\n      // watch directory\\n      else {\\n        const filterGuard = guard(info.options.filter);\\n        filterGuard(name, function() {\\n          if (self.flag) self.flag = '';\\n          else self.emit('change', event, name);\\n        });\\n      }\\n    });\\n\\n    watcher.on('error', function(error) {\\n      if (self.isClosed()) {\\n        return;\\n      }\\n      if (is.windows() && error.code === 'EPERM') {\\n        watcher.emit('change', EVENT_REMOVE, info.fpath && '');\\n        self.flag = 'windows-error';\\n        self.close(watcherPath);\\n      } else {\\n        self.emit('error', error);\\n      }\\n    });\\n\\n    watcher.on('change', internalOnChange);\\n  };\\n\\n  Watcher.prototype.watchFile = function(file, options, fn) {\\n    const parent = path.join(file, '../');\\n    const options_ = {\\n      ...options, // no filter for single file\\n      filter: null,\\n      encoding: 'utf8',\\n    };\\n\\n    // no need to watch recursively\\n    delete options_.recursive;\\n\\n    const watcher = fs.watch(parent, options_);\\n    this.add(watcher, {\\n      type: 'file',\\n      fpath: parent,\\n      options: { ...options_, encoding: options.encoding },\\n      compareName(n) {\\n        return is.samePath(n, file);\\n      },\\n    });\\n\\n    if (is.func(fn)) {\\n      if (fn.length === 1) deprecationWarning();\\n      this.on('change', fn);\\n    }\\n  };\\n\\n  Watcher.prototype.watchDirectory = function(dir, options, fn, counter = nullCounter) {\\n    const self = this;\\n    const done = counter();\\n    hasNativeRecursive(function(has) {\\n      // always specify recursive\\n      options.recursive = !!options.recursive;\\n      // using utf8 internally\\n      const options_ = { ...options, encoding: 'utf8' };\\n      if (!has) {\\n        delete options_.recursive;\\n      }\\n\\n      const watcher = fs.watch(dir, options_);\\n\\n      self.add(watcher, {\\n        type: 'dir',\\n        fpath: dir,\\n        options,\\n      });\\n\\n      if (is.func(fn)) {\\n        if (fn.length === 1) deprecationWarning();\\n        self.on('change', fn);\\n      }\\n\\n      if (options.recursive && !has) {\\n        getSubDirectories(\\n          dir,\\n          function(d) {\\n            self.watchDirectory(d, options, null, counter);\\n          },\\n          counter(),\\n        );\\n      }\\n\\n      done();\\n    });\\n  };\\n\\n  function composeWatcher(watchers) {\\n    const watcher = new Watcher();\\n    const filterDups = createDupsFilter();\\n    let counter = watchers.length;\\n    watchers.forEach(function(w) {\\n      w.on(\\n        'change',\\n        filterDups(function(event, name) {\\n          watcher.emit('change', event, name);\\n        }),\\n      );\\n      w.on('error', function(error) {\\n        watcher.emit('error', error);\\n      });\\n      w.on('ready', function() {\\n        if (!--counter) {\\n          emitReady(watcher);\\n        }\\n      });\\n    });\\n\\n    watcher.close = function() {\\n      watchers.forEach(function(w) {\\n        w.close();\\n      });\\n      process.nextTick(emitClose, watcher);\\n    };\\n    return watcher.expose();\\n  }\\n\\n  function watch(fpath, options, fn) {\\n    const watcher = new Watcher();\\n\\n    if (is.buffer(fpath)) {\\n      fpath = fpath.toString();\\n    }\\n\\n    if (is.array(fpath)) {\\n      if (fpath.length === 1) {\\n        return watch(fpath[0], options, fn);\\n      }\\n      const filterDups = createDupsFilter();\\n      return composeWatcher(\\n        unique(fpath).map(function(f) {\\n          const w = watch(f, options);\\n          if (fn) w.on('change', filterDups(fn));\\n          return w;\\n        }),\\n      );\\n    }\\n\\n    if (!is.exists(fpath)) {\\n      watcher.emit('error', new Error(`${fpath} does not exist.`));\\n    }\\n\\n    if (is.string(options)) {\\n      options = {\\n        encoding: options,\\n      };\\n    }\\n\\n    if (is.func(options)) {\\n      fn = options;\\n      options = {};\\n    }\\n\\n    if (arguments.length < 2) {\\n      options = {};\\n    }\\n\\n    if (options.encoding) {\\n      assertEncoding(options.encoding);\\n    } else {\\n      options.encoding = 'utf8';\\n    }\\n\\n    if (is.file(fpath)) {\\n      watcher.watchFile(fpath, options, fn);\\n      emitReady(watcher);\\n    } else if (is.directory(fpath)) {\\n      const counter = semaphore(function() {\\n        emitReady(watcher);\\n      });\\n      watcher.watchDirectory(fpath, options, fn, counter);\\n    }\\n\\n    return watcher.expose();\\n  }\\n\\n  module.exports = watch;\\n  module.exports.default = watch;\\n}\\nwatchIIFE();\\n\",\n            \"creator\": \"LinOnetwo\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"startup\"\n        }\n    }\n}"}